---
title: "R Notebook"
output: html_notebook
---

#https://stackoverflow.com/questions/39435240/rstudio-changing-origin-for-git-version-control-of-project

#Load some libraries
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(viridis)
```


```{r}

clustRnormal <- read.csv(file="data/clusterData.csv") # z scored values
clustR <- clustRnormal
# clustR 


```

#Making Long dataframe with geomFeatures and values
```{r}
# colnames(clustR)
long_clustR <- 
  clustR %>% pivot_longer(
    cols = contains("_cell") |
      contains("_nucleus")   | 
      contains("Intensity")  |
      contains("NucleusVolumeFraction")|
      contains("Dim")|
      contains("Diameter")|
      contains("AngleBetween")|
      contains("Orbit"),
    names_to = "geomFeatures" 
        )


long_clustR


#Make metadata chart

colnames(long_clustR)


CellID_metaData <- long_clustR %>%
  select(cellNumber,
         # CoverslipPresent,
         # CoverslipDistance, 
         # OnCoverslip, 
         fieldNumber, 
         Treatment,
         Row, 
         Column, 
         Plate 
         )

```

#make wide dataframe with columns that are cell ID and geom features
```{r}

#keep only runNumber (timepoint, as an organising coolum)
#keep only first 45 timepoints

wide_cellID_geomFeature <- long_clustR %>%
                            select(runNumber,cellNumber,geomFeatures,value)%>%
                            filter(runNumber < 46) %>%
                            pivot_wider(names_from = c("cellNumber","geomFeatures"),
                                       values_from = "value",
                                       names_sep = "_FeatureID_")

wide_cellID_geomFeature

# ?pivot_wider()

(head(wide_cellID_geomFeature))
```




#Make some labels of cell and nucleus features
https://www.marsja.se/how-to-use-in-in-r/

https://www.journaldev.com/43690/sub-and-gsub-function-r


#Look at correlation of nuclear and cell dynamics
```{r}

colnames(long_clustR)

long_clustR$feature_type <- ifelse(grepl("_cell",long_clustR$geomFeatures), "cell_feature", 
                                          ifelse(grepl("_nucleus",long_clustR$geomFeatures), "nucleus_feature","whole_object"))

long_clustR$highLevelFeatures <- gsub("_cell","",long_clustR$geomFeatures)  
long_clustR$highLevelFeatures <- gsub("_nucleus","",long_clustR$highLevelFeatures)
long_clustR$highLevelFeatures <- as.factor(long_clustR$highLevelFeatures)


#cellNumber (need also cell Number fused to each feature type)
  #the line is going to every point belonging to that cell,
  #make two versions of each cellObject, one that is nuclear and one that is cellular

long_clustR$cellNumberCompartment <- paste(long_clustR$cellNumber,"_",long_clustR$feature_type)

# long_clustR$cellNumberCompartment

unique(long_clustR$geomFeatures)


```


#potential problem, this doubles the number of time each cell appears (should be 108,000 rows, but 216,000)
```{r}
wideIDfeatures <- wide_cellID_geomFeature
chosenFeature <- "Eccentricity"#

write.csv(wide_cellID_geomFeature, file="widetimeSeries.csv")
```


```{r}
head(wideIDfeatures)

pairedOPM_CCF <- function(wideIDfeatures){

final_df_particular_CCF_Object <- data.frame()  
  
  library(stringr)  
  #one liner to get unique cellIDs Features from colnames of wide dataframe
  listOfccfCellIDs <- unique(as.data.frame(str_split_fixed(colnames(wideIDfeatures[-1]), "_FeatureID_",2))[,1]) # about 250 cells
  
  listOFccFFeatures <- unique(as.data.frame(str_split_fixed(colnames(wideIDfeatures[-1]), "_FeatureID_",2))[,2])
  listOFccFFeatures
  #select only features that are present for BOTH cell and nucleus
  # nc_listOFccFFeatures <- listOFccFFea
  
  nc_listOFccFFeatures <-  as.data.frame(listOFccFFeatures) %>%
    dplyr::filter(grepl("_cell|_nucleus",listOFccFFeatures))
  
  nc_listOFccFFeatures
#remove nucleus and cell from feature names

  sub_nc_listOFccFFeatures <- gsub("_nucleus|_cell","",nc_listOFccFFeatures$listOFccFFeatures)
  
#reassign list of features
  vector_nc_listOFccFFeatures <- sub_nc_listOFccFFeatures

  #make unique as features duplicated due to removal of Cell/nucleus suffix  29/11/21
  vector_nc_listOFccFFeatures <- unique(vector_nc_listOFccFFeatures)
  
  #loop through feature in list
  for(sub_chosenFeature in vector_nc_listOFccFFeatures){
  
  an_chosenFeatureCell <- paste0(sub_chosenFeature,"_cell")
  an_chosenFeatureNucleus <- paste0(sub_chosenFeature,"_nucleus")
  #now paste rownames back onto feature of interest
  
#Loop through all features
  
  
#Loop through all cells
for(cellID in listOfccfCellIDs){
 
    print(paste("STARTing cell..",cellID, " With feature...",sub_chosenFeature))
  
  
lookupCell <-   paste0(cellID,'_FeatureID_',an_chosenFeatureCell)
lookupNucleus <-  paste0(cellID,'_FeatureID_',an_chosenFeatureNucleus)
     
  #subset by column name
    
library(dplyr)
#NB Using "pull" here to make data into vector isntead of dataframe but this function might be slow
  chosenTSone_y_cell <- pull(wideIDfeatures[,lookupCell])
  # chosenTSone_y_cell
  choseTStwo_x_nucleus <- pull(wideIDfeatures[,lookupNucleus])
  
  
  
  #generate CCF
  particularCellFeatureCCF <- ccf(chosenTSone_y_cell, choseTStwo_x_nucleus, plot = FALSE, na.action = na.pass)
  str(particularCellFeatureCCF)

  #make an object ID
# particular_CCF_ObjectID <- rep(paste)

anCCF_ACF <- particularCellFeatureCCF$acf
anCCF_LAG <- particularCellFeatureCCF$lag

an_CCF_ObjectID <- paste(rep(cellID, length(particularCellFeatureCCF$lag)))
an_CCF_Feature <- sub_chosenFeature

# particular_acfObjectTreatment <- rep(rep(paste(titlePlot), length(particular_acfObject$acf))) 
particular_CCF_Object_output <- data.frame(anCCF_ACF , anCCF_LAG, an_CCF_ObjectID, an_CCF_Feature)

print(paste("adding Cell to dataframe...",cellID))
final_df_particular_CCF_Object <- rbind(final_df_particular_CCF_Object, particular_CCF_Object_output)
    print(paste("ENDing cell..",cellID, " With feature...",sub_chosenFeature))

}
  

  }
return(final_df_particular_CCF_Object)
  }
# final_df_particular_CCF_Object
# wide_cellID_geomFeature

# for(cell in ListOfAllCells)
# wide_cellID_geomFeature
```


```{r}
outputCCFdata <-  pairedOPM_CCF(wideIDfeatures)
write.csv(outputCCFdata,file="nuc_cell_CCF_data.csv", row.names = FALSE)
str(outputCCFdata)
head(outputCCFdata,50)


outputCCFdata[outputCCFdata$an_CCF_ObjectID == 219 & outputCCFdata$anCCF_LAG ==1 & outputCCFdata$an_CCF_Feature == "Volume", ]

```


#Linking treatments
```{r}
# str(CellID_metaData)
outputCCFdata$an_CCF_ObjectID <- as.numeric(outputCCFdata$an_CCF_ObjectID)
# str(outputCCFdata)
# 
# acfOutput



unq_CellID_metaData <- unique(CellID_metaData)
unq_CellID_metaData


outputCCFdata
unq_CellID_metaData

library(dplyr)
join_outputCCFdata <- left_join(outputCCFdata, unq_CellID_metaData, by = c("an_CCF_ObjectID"="cellNumber"))

# join_out

dim(join_outputCCFdata)


# (outputCCFdata$anCCF_ACF)
```






```{r}
#make this a living heatpam --> get mean at lag zero, put DMSO first, remove coordinates?
colnames(join_outputCCFdata)
join_outputCCFdata$anCCF_ACF
mean_ccfLAGzero <- join_outputCCFdata %>%
    filter(anCCF_LAG == 0)%>%
  group_by(Treatment, an_CCF_Feature)%>%
  summarise(meanLAGzero = mean(anCCF_ACF, na.rm = TRUE))
mean_ccfLAGzero
#   # select(anCCF_ACF)%>%
#   summarise(meanCCF = mean(., na.rm = TRUE))

mean_ccfLAGzero
# colnames(join_outputCCFdata)
sum_join_outputCCFdata <- left_join(join_outputCCFdata, mean_ccfLAGzero, by = c("Treatment", "an_CCF_Feature"))
sum_join_outputCCFdata
#bring DMSO to front

colnames(sum_join_outputCCFdata)


head(sum_join_outputCCFdata[,],20)

#reorder so DMSO is first
# levels(sum_join_outputCCFdata$Treatment)

# sum_join_outputCCFdata$Treatment   <- as.factor(sum_join_outputCCFdata$Treatment)
# sum_join_outputCCFdata$Treatment <- relevel(sum_join_outputCCFdata$Treatment, "DMSO")
# sum_join_outputCCFdata$Treatment <- ordered(sum_join_outputCCFdata$Treatment , levels = c("DMSO", "Blebbistatin", "H1152","CK666","Palbociclib","PF228"))

levels(sum_join_outputCCFdata$Treatment)


#hmm
#remove coord features
#1 12 21 leave in coord features as there expected behaviour makes them good for flagging when a function is not working as expected
subset_sum_join_outputCCFdata <- sum_join_outputCCFdata[!grepl("Coord",sum_join_outputCCFdata$an_CCF_Feature),]


# subset_sum_join_outputCCFdata <- sum_join_outputCCFdata

# subset_sum_join_outputCCFdata <- sum_join_outputCCFdata[grepl("Coord",sum_join_outputCCFdata$an_CCF_Feature),]
# subset_sum_join_outputCCFdata
# 
# sum_join_outputCCFdata$an_CCF_Feature

```



#meanLagZero for zCoord etc is good up to here

#create a matrix in preparation to cluster cell and nuclear correlations
```{r}
colnames(subset_sum_join_outputCCFdata)

unq_subset_sum_join_outputCCFdata<- unique(subset_sum_join_outputCCFdata)

unq_subset_sum_join_outputCCFdata

library(tidyr)
m_wide_subset_sum_join_outputCCFdata <- subset_sum_join_outputCCFdata %>%
  select(meanLAGzero,an_CCF_Feature,Treatment)%>%
  unique()%>%
  pivot_wider(
                                                    id_col = c("meanLAGzero","an_CCF_Feature","Treatment"),
                                                    names_from = "Treatment",
                                                    values_from = "meanLAGzero"
                                                    )


m_wide_subset_sum_join_outputCCFdata


str(m_wide_subset_sum_join_outputCCFdata)


```


http://www.cookbook-r.com/Manipulating_data/Changing_the_order_of_levels_of_a_factor/

#cluster data by mean correlation at lag zero
```{r}

#add rownames and remove first column to make numeric matrix
rnames_m_wide_subset_sum_join_outputCCFdata <- m_wide_subset_sum_join_outputCCFdata
rownames(rnames_m_wide_subset_sum_join_outputCCFdata) <- m_wide_subset_sum_join_outputCCFdata$an_CCF_Feature

mCCF_lagZero <- as.matrix(rnames_m_wide_subset_sum_join_outputCCFdata[-1]) #make a matrix
rownames(mCCF_lagZero) <-  m_wide_subset_sum_join_outputCCFdata$an_CCF_Feature # add rownames to matrix

row.order <- hclust(dist(mCCF_lagZero))$order # get row order from clustered matrix and set this as a  variable
col.order <- hclust(dist(t(mCCF_lagZero)))$order # get column order from clustered matrix and set this as a variable

row.order
col.order

mCCF_lagZero[row.order, col.order]

# get list of rows with names for ordering (order the factor this way)
featureOrder <- m_wide_subset_sum_join_outputCCFdata$an_CCF_Feature # make the features a variable called feature order
featureOrder # look at current feature order (this is order will be plotted in ggplot)
newFeatureOrder <- featureOrder[row.order] #make a new or desired feature order based on the row order
featureOrder <- factor(featureOrder, levels = newFeatureOrder) # reorder the factor levels of the feature to match the clsutering
featureOrder 

# Treatment orders (do same process for factors but for treatments)
treatmentOrder <- colnames(mCCF_lagZero)
newTreatmentOrder <- treatmentOrder[col.order]
treatmentOrder <- factor(treatmentOrder, levels = newTreatmentOrder)

#update main dataframe (update the factor levels for Treatments and Features, to be based on clustering)
subset_sum_join_outputCCFdata$Treatment <- factor(subset_sum_join_outputCCFdata$Treatment, levels =newTreatmentOrder)
subset_sum_join_outputCCFdata$an_CCF_Feature  <- factor(subset_sum_join_outputCCFdata$an_CCF_Feature, levels = newFeatureOrder)
```

#plot unclustered and clustered data
```{r}
# library(ggplot2)
ggplot(subset_sum_join_outputCCFdata, aes(x =anCCF_LAG, y = anCCF_ACF, group = an_CCF_ObjectID))+
  geom_line(alpha = 0.1)+
  facet_wrap(~an_CCF_Feature)+
    stat_summary(aes(y = anCCF_ACF,group=1), fun.y=mean, colour="darkorange", geom="line",group=1, size = 1)+
  theme_classic()

# join_outputCCFdata
ggplot(subset_sum_join_outputCCFdata, aes(x =anCCF_LAG, y = anCCF_ACF, group = an_CCF_ObjectID, color = Treatment))+
  geom_line(alpha = 0.1)+
    facet_grid( vars(an_CCF_Feature),vars(Treatment) )+
    stat_summary(aes(y = anCCF_ACF,group=1), fun.y=mean, colour="gray20", geom="line",group=1, size = 1)+
  theme_classic()
  
#Clustered, and coloured by mean, with identicle feature removed
ggplot(subset_sum_join_outputCCFdata[,],
       aes(x =subset_sum_join_outputCCFdata$anCCF_LAG, y = subset_sum_join_outputCCFdata$anCCF_ACF, group = subset_sum_join_outputCCFdata$an_CCF_ObjectID, color = subset_sum_join_outputCCFdata$meanLAGzero))+
  geom_line(alpha = 0.5)+
  scale_color_viridis_c(option ="magma")+
    facet_grid( vars(an_CCF_Feature),vars(Treatment) )+
    stat_summary(aes(y = subset_sum_join_outputCCFdata$anCCF_ACF,group=1), fun.y=mean, colour="gray20", geom="line",group=1, size = 1)+
  theme_classic()

#Clustered and background coloured
ggplot(subset_sum_join_outputCCFdata[,],
       aes(x =subset_sum_join_outputCCFdata$anCCF_LAG, y = subset_sum_join_outputCCFdata$anCCF_ACF, group = subset_sum_join_outputCCFdata$an_CCF_ObjectID))+
  geom_rect(data=subset_sum_join_outputCCFdata, aes(ymin=-1, ymax=1, xmin=-15,
                       xmax=15, fill=subset_sum_join_outputCCFdata$meanLAGzero, color = subset_sum_join_outputCCFdata$meanLAGzero), alpha =0.1)+

  geom_line(alpha = 0.5)+
  scale_color_viridis_c(option ="magma")+
    scale_fill_viridis_c(option ="magma")+
    facet_grid( vars(an_CCF_Feature),vars(Treatment) )+
    stat_summary(aes(y = subset_sum_join_outputCCFdata$anCCF_ACF,group=1), fun.y=mean, colour="darkorange", geom="line",group=1, size = 1)+
  theme_classic()

```




```{r}
#1. Get differnece in all lags 


testArranger_join_outputCCFdata <- join_outputCCFdata %>%
    arrange(an_CCF_ObjectID,an_CCF_Feature, Treatment,anCCF_LAG,)%>%
    group_by(an_CCF_ObjectID, an_CCF_Feature,Treatment)
    # mutate_at("anCCF_ACF", ~ . - dplyr::lag(., n = 1, default = NA),.keep = "all" )



diff_join_outputCCFdata <- join_outputCCFdata %>%
    arrange(an_CCF_ObjectID,an_CCF_Feature, Treatment,anCCF_LAG)%>%
    group_by(an_CCF_ObjectID, an_CCF_Feature,Treatment) %>%
    mutate_at("anCCF_ACF", ~ . - dplyr::lag(., n = 1, default = NA),.keep = "all" )




diff_join_outputCCFdata$CCF_diff <- diff_join_outputCCFdata$anCCF_ACF

head(testArranger_join_outputCCFdata)
head(diff_join_outputCCFdata)

#create absolute difference measure (getting absolute change in correlation)
diff_join_outputCCFdata$absCCF_diff <- abs(diff_join_outputCCFdata$CCF_diff)
abs(diff_join_outputCCFdata$absCCF_diff)
diff_join_outputCCFdata

#2. get average difference for lags less than 0

diff_join_outputCCFdata$lagRange <- ifelse(diff_join_outputCCFdata$anCCF_LAG >-7 & diff_join_outputCCFdata$anCCF_LAG <0 , "negativeLAG",
                                           ifelse(diff_join_outputCCFdata$anCCF_LAG >0 & diff_join_outputCCFdata$anCCF_LAG <7, "positiveLAG", 
                                                  ifelse(diff_join_outputCCFdata$anCCF_LAG == 0, "zeroLAG", "OutOfLagRange")))


#doing individual
#NB, could do overall averages and then summarise this

##Possible MISTAKE --> Need to group by lag range?
diff_join_outputCCFdata

summary_meandiff_overLAGrange_join_outputCCFdata <- diff_join_outputCCFdata %>%
  group_by(an_CCF_ObjectID, an_CCF_Feature,Treatment,lagRange)%>%
  dplyr::summarise(meanLAGdiff = mean(anCCF_ACF, na.rm = TRUE),
                   meanAbsLAGdiff = mean(absCCF_diff, na.rm = TRUE))

summary_meandiff_overLAGrange_join_outputCCFdata

library(tidyr)
colnames(summary_meandiff_overLAGrange_join_outputCCFdata)
widerDiffs <- pivot_wider(summary_meandiff_overLAGrange_join_outputCCFdata,
                          id_cols = c("an_CCF_ObjectID","an_CCF_Feature","Treatment","meanAbsLAGdiff","lagRange"),
                          names_from = "lagRange",
                          values_from = "meanAbsLAGdiff") 



  

 widerDiffs$priorToPostRatio <- widerDiffs$negativeLAG/widerDiffs$positiveLAG
head(widerDiffs)
#rejoin ratios back to main summary
widerDiffs[,c(1,2,3,7)]

join_summary_meandiff_overLAGrange_join_outputCCFdata <- left_join(summary_meandiff_overLAGrange_join_outputCCFdata, widerDiffs[,c(1,2,3,7)], by = c("an_CCF_ObjectID","an_CCF_Feature","Treatment"))

dim(summary_meandiff_overLAGrange_join_outputCCFdata)
dim(join_summary_meandiff_overLAGrange_join_outputCCFdata)  


?pivot_wider()
head(summary_meandiff_overLAGrange_join_outputCCFdata)  

#3. Get average difference for lags greater than 0

# -0.1781466	--0.1402122	

```




#look back to original data based on this
#get difference between pre and post lags
```{r}

#changes on 1 12 21

join_outputCCFdata$lagRange <- ifelse(diff_join_outputCCFdata$anCCF_LAG >-15 & diff_join_outputCCFdata$anCCF_LAG <0 , "negativeLAG",
                                           ifelse(diff_join_outputCCFdata$anCCF_LAG >0 & diff_join_outputCCFdata$anCCF_LAG <15, "positiveLAG", 
                                                  ifelse(diff_join_outputCCFdata$anCCF_LAG == 0, "zeroLAG", "OutOfLagRange")))



# # Define ranges of lags around zero
# join_outputCCFdata$lagRange <- ifelse(join_outputCCFdata$anCCF_LAG >-15 & join_outputCCFdata$anCCF_LAG <0 , "negativeLAG",
#                                            ifelse(join_outputCCFdata$anCCF_LAG >0 & join_outputCCFdata$anCCF_LAG <15, "positiveLAG",
#                                                   "zeroLAG"))

library(dplyr)

# join_outputCCFdata$lagRange

#calculate averages in lags (not in lag Diffs)
meanLagRange_join_outputCCFdata <- join_outputCCFdata %>%
    arrange(an_CCF_ObjectID,an_CCF_Feature, Treatment,anCCF_LAG)%>%
    group_by(an_CCF_ObjectID, an_CCF_Feature,Treatment, lagRange) %>%
  dplyr::summarise(meanACFforLAG = mean(anCCF_ACF, na.rm = TRUE))

meanLagRange_join_outputCCFdata

library(tidyr)
wider_meanLagRange_join_outputCCFdata <- pivot_wider(meanLagRange_join_outputCCFdata,
                          id_cols = c("an_CCF_ObjectID","an_CCF_Feature","Treatment","meanACFforLAG","lagRange"),
                          names_from = "lagRange",
                          values_from = "meanACFforLAG") 

str(wider_meanLagRange_join_outputCCFdata)

wider_meanLagRange_join_outputCCFdata$meanPrior_meanPost_diff <- wider_meanLagRange_join_outputCCFdata$negativeLAG - wider_meanLagRange_join_outputCCFdata$positiveLAG  

# wider_meanLagRange_join_outputCCFdata
wider_meanLagRange_join_outputCCFdata

# str(wider_meanLagRange_join_outputCCFdata$meanPrior_meanPost_diff)

wider_meanLagRange_join_outputCCFdata$priorToPostRatio <- wider_meanLagRange_join_outputCCFdata$negativeLAG/wider_meanLagRange_join_outputCCFdata$positiveLAG

colnames(wider_meanLagRange_join_outputCCFdata)

#join prior to post ratio back to dataframe
join_meanLagRange_join_outputCCFdata <- left_join(summary_meandiff_overLAGrange_join_outputCCFdata, wider_meanLagRange_join_outputCCFdata[,c(1,2,3,7,8)], by = c("an_CCF_ObjectID","an_CCF_Feature","Treatment"))

# wider_meanLagRange_join_outputCCFdata
dim(meanLagRange_join_outputCCFdata)
dim(join_meanLagRange_join_outputCCFdata)


# -1.876928e-01 -0.0756655222


#get overall feature mean

# join_meanLagRange_join_outputCCFdata$meanAbsLAGdiff
summaryOfMedianDifferencePriorAndPost<- join_meanLagRange_join_outputCCFdata %>%
  group_by(an_CCF_Feature,Treatment)%>%
  summarise(medianPrePostPerTF = median(meanPrior_meanPost_diff))


summaryOfMedianDifferencePriorAndPost


join_medianDiff_meanLagRange_join_outputCCFdata <- left_join(join_meanLagRange_join_outputCCFdata, summaryOfMedianDifferencePriorAndPost, by = c("an_CCF_Feature","Treatment"))
dim(join_meanLagRange_join_outputCCFdata)
dim(join_medianDiff_meanLagRange_join_outputCCFdata)

```

```{r}
library(ggplot2)
library(viridis)
#subset to remove zero lag, and also Coord
subset_meanLagRange_join_outputCCFdata <- join_meanLagRange_join_outputCCFdata[(!grepl("Coord",join_meanLagRange_join_outputCCFdata$an_CCF_Feature)) & 
                                                                                join_meanLagRange_join_outputCCFdata$lagRange != "zeroLAG" ,]
                    
subset_meanLagRange_join_outputCCFdata$ratioBin <- ifelse(subset_meanLagRange_join_outputCCFdata$priorToPostRatio > 0.2, "Prior is dominant", 
                                                          ifelse(subset_meanLagRange_join_outputCCFdata$priorToPostRatio < 0.2, "Post is dominant", "Correlation even")
                                                          )
```


```{r}

#get DMSO order of C and N correlation
reOrderDFfeatures <- as.data.frame((unique(join_medianDiff_meanLagRange_join_outputCCFdata[join_medianDiff_meanLagRange_join_outputCCFdata$Treatment =="DMSO",c("an_CCF_Feature","medianPrePostPerTF")])))

#Reorder based on that
reOrderDFfeatures$an_CCF_Feature <- as.factor(reOrderDFfeatures$an_CCF_Feature)

#Make this the order of factor levels
library(forcats)
reOrderDFfeatures$an_CCF_Feature <- fct_reorder(reOrderDFfeatures$an_CCF_Feature,reOrderDFfeatures$medianPrePostPerTF, .desc = FALSE)

levels(reOrderDFfeatures$an_CCF_Feature)

subset_meanLagRange_join_outputCCFdata$an_CCF_Feature <- factor(subset_meanLagRange_join_outputCCFdata$an_CCF_Feature, levels = levels(reOrderDFfeatures$an_CCF_Feature))
# subset_meanLagRange_join_outputCCFdata$an_CCF_Feature <- factor()


subset_meanLagRange_join_outputCCFdata[subset_meanLagRange_join_outputCCFdata$an_CCF_Feature != "nProtrusions",]
```



```{r}

#make a heatmap of average correlation before and after lag 0

join_medianDiff_meanLagRange_join_outputCCFdata

PrePostcorrelation <- join_medianDiff_meanLagRange_join_outputCCFdata[join_medianDiff_meanLagRange_join_outputCCFdata$an_CCF_Feature != "nProtrusions",]
PrePostcorrelation <-  PrePostcorrelation %>%
  filter(!grepl("Coord", an_CCF_Feature))
  
filteredForM_PrePostcorrelation<-PrePostcorrelation[,c(2,3,9)]
dim(filteredForM_PrePostcorrelation)
filteredForM_PrePostcorrelation <- unique(filteredForM_PrePostcorrelation)

wide_filteredForM_PrePostcorrelation <- pivot_wider(filteredForM_PrePostcorrelation,
                                                    names_from = Treatment,
                                                    values_from = medianPrePostPerTF)


wide_filteredForM_PrePostcorrelation

mw_prePost <- as.matrix(wide_filteredForM_PrePostcorrelation[-1])
rownames(mw_prePost) <- wide_filteredForM_PrePostcorrelation$an_CCF_Feature  

library(ComplexHeatmap)

library(circlize)
col_fun = colorRamp2(c(min(mw_prePost), 0,max(mw_prePost)), c("steelblue4", "white", "gold"))
col_fun(seq(-10, 10))


Heatmap(mw_prePost, col = col_fun)


```




#Get PC loadings for features, make this as size

```{r}

#Join mean lag at time zero info on prior and post diffs, to this <-- to get strength of correlation

# join_medianDiff_meanLagRange_join_outputCCFdata
# mean_ccfLAGzero
joinMedLagPrePostDiff_meanLagZero <- left_join(join_medianDiff_meanLagRange_join_outputCCFdata, mean_ccfLAGzero, by = c("an_CCF_Feature","Treatment"))

# mean_ccfLAGzero

library(ggplot2)
subset_joinMedLagPrePostDiff_meanLagZero <- joinMedLagPrePostDiff_meanLagZero[!grepl("Coord",joinMedLagPrePostDiff_meanLagZero$an_CCF_Feature),]

ggplot(joinMedLagPrePostDiff_meanLagZero[joinMedLagPrePostDiff_meanLagZero$lagRange =="zeroLAG",], aes(x = medianPrePostPerTF, y = meanLAGzero, color = an_CCF_Feature))+
  geom_point()+
  facet_wrap(~Treatment)+
  theme_classic()


ggplot( )+
    annotate("rect",xmin = -Inf, xmax = 0, ymin = -Inf, ymax = Inf,  fill = "navy",alpha = 0.1)+
  annotate("rect",xmin = 0, xmax = Inf, ymin = -Inf, ymax = Inf,  fill = "orange",alpha = 0.1)+
  geom_point(data = subset_joinMedLagPrePostDiff_meanLagZero[subset_joinMedLagPrePostDiff_meanLagZero$lagRange =="zeroLAG",], aes(x = medianPrePostPerTF, y = meanLAGzero, color = an_CCF_Feature), size = 2)+
  scale_color_viridis(discrete =TRUE)+
  facet_wrap(~Treatment)+
  theme_classic()+
  geom_vline(xintercept = 0, alpha = 0.2)

  # geom_rect(xmin = -Inf, xmax = 0, ymin = -Inf, ymax = Inf, aes( color = "grey",alpha = 0.2) )


ggplot( )+
    annotate("rect",xmin = -Inf, xmax = 0, ymin = -Inf, ymax = Inf,  fill = "#2c7da0",alpha = 0.3)+
  annotate("rect",xmin = 0, xmax = Inf, ymin = -Inf, ymax = Inf,  fill = "#fff3b0",alpha = 0.3)+
  geom_point(data = subset_joinMedLagPrePostDiff_meanLagZero[subset_joinMedLagPrePostDiff_meanLagZero$lagRange =="zeroLAG",], aes(x = medianPrePostPerTF, y = meanLAGzero, fill = an_CCF_Feature), pch=21, size = 3, alpha = 0.9)+
  # scale_color_viridis(discrete =TRUE)+
  scale_fill_manual(
    values = c(
      "#264653",
"#2a9d8f",
"#e9c46a",
"#f4a261",
"#e76f51",
"#e63946",
"#f1faee",
"#a8dadc",
"#457b9d",
"#1d3557",
"#560bad",
"#6b705c",
"#f28482"
    )
  )+
  facet_wrap(~Treatment)+
  # geom_vline(xintercept = 0, alpha = 0.2)+
    theme_classic()
# 
# "#264653"
# "#2a9d8f"
# "#e9c46a"
# "#f4a261"
# "#e76f51"
# "#e63946"
# "#f1faee"
# "#a8dadc"
# "#457b9d"
# "#1d3557"
# "#560bad"
# "#6b705c"


```