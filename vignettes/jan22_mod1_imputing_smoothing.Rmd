---
title: "R Notebook"
output: html_notebook
---

---
title: "R Notebook"
output: html_notebook
---

#Script to:
1. impute NA (of gap 1 or 2)
--> moving average
2. get time series of:
  i. equal length? 
  ii. or of at least 45 consecutive timepoints
3. smooth time series to avoid noise with:
i. moving average 
  https://cran.r-project.org/web/packages/smooth/vignettes/sma.html
ii. savitsky golay


#Savitsky golay in R
#INSTALL savitsky golay filters
```{r}
getwd()
# install.packages("prospectr")
library(prospectr)
# install.packages("signal")
library(signal)

library(imputeTS)

library(purrr)

```



#Read in the data

```{r}

clustRraw <- read.csv(file="data/allStats5_plateA.csv") # raw values
clustRnormal <- read.csv(file="data/clusterData.csv") # z scored values
clustRchange <- read.csv(file = "data/changeData.csv") # differences between time points

clustR <- clustRraw

```


#Fixing missing values 
# Sort data by cells and run number
# Identify gaps in runNumber for each cell
# Impute missing values within a cell but not between cells
# Add a "rebased" run number that marks the start of each cells 45 section timeseries

```{r}
#rearrange dataframe to sort by cell number and time point
# head(clustRraw)
# 
# colnames(clustRraw)

library(dplyr)
cell_run_sorted_clustRaw <- clustR %>%
  arrange(cellNumber,runNumber) %>%
  select(cellNumber,runNumber,everything())

head(cell_run_sorted_clustRaw)

```


#Make a master timePointframe in R
#max value is max timepoint in runNumber
```{r}
#make a master dataframe that explicitly puts in na's where timepoints are missing

timePoint_structure <- seq_along(1:max(cell_run_sorted_clustRaw$runNumber))
cellNumber_structure <- unique(cell_run_sorted_clustRaw$cellNumber) 

# Print each cell ID number 49 (length of time frame) times
cellNumber_frame <- lapply(cellNumber_structure, function(x) paste(rep(x,length(timePoint_structure)))) 
c_IDcellNumber_frame <- do.call(c,cellNumber_frame)
head(c_IDcellNumber_frame)

#Count from 1 to 49, 250 times
timePoint_frame <- paste0(rep(timePoint_structure, times = length(cellNumber_frame)))
head(timePoint_frame)

cellAndtime_frame <- data.frame(c_IDcellNumber_frame, timePoint_frame)

cellAndtime_frame$c_IDcellNumber_frame <- as.numeric(cellAndtime_frame$c_IDcellNumber_frame) 
cellAndtime_frame$timePoint_frame <- as.numeric(cellAndtime_frame$timePoint_frame)

```

#Join data to timeFrame info
```{r}
#join dataframe with measurements to rigid time frame

library(dplyr)
join_cellAndtime_frame <- left_join(cellAndtime_frame, cell_run_sorted_clustRaw, by = c("c_IDcellNumber_frame" = "cellNumber", "timePoint_frame" = "runNumber"))

head(join_cellAndtime_frame)


#make a column to find NA values


# join_cellAndtime_frame$valueImputed <- ifelse(rowSums(is.na(join_cellAndtime_frame))>0,"imputedValue","measuredValue")
join_cellAndtime_frame$valueImputed <- ifelse((is.na(join_cellAndtime_frame$serialNumber))>0,"imputedValue","measuredValue")

head(join_cellAndtime_frame$valueImputed)


metadata_join_cellAndtime_frame <- join_cellAndtime_frame #Metadata columns here can be joined later


```
#This section is motivated by not being able to find syntax to use imputeTS and savitsky golay filter on time tracks while grouping by cellID and feature 
#Make long to collect GeomFeatures and Measure for combination with cellID
#Then make wide to combine each cell and geomFeature, but remove other metadata featuers 
```{r}
library(tidyr)

#join_cellAndtime_frame

#pivot longer so that measures are in a single column
# then wider with just time points

library(tidyr)
colnames(join_cellAndtime_frame)

long_join_cellAndtime_frame <- pivot_longer(join_cellAndtime_frame,
             cols =  contains("_cell") | contains ("_nucleus") | contains("ntensity") | contains("Dim") | contains("Between") | contains("Orbit") | contains("Fraction") | contains("EquivDiameter"), #select measure to keep 
             names_to = "geomFeature", 
             values_to = "geomMeasure")

head(long_join_cellAndtime_frame)


#Make wider for time 

#pivot wider so that measure and cell ID are merged into one column 
#This makes it easy to use the syntax of "imputeTS" package, to remove NA with moving average or other

long_join_cellAndtime_frame$verbose_cellID <- paste0("cell",long_join_cellAndtime_frame$c_IDcellNumber_frame,"_") # make cellID label that is easier for gsub later

wider_long_join_cellAndTime <- pivot_wider(long_join_cellAndtime_frame[,c(
                                                                          "timePoint_frame",
                                                                          "verbose_cellID",
                                                                          # "c_IDcellNumber_frame",
                                                                          # "Treatment",
                                                                          # "Row",
                                                                          # "Column",
                                                                          # "Plate",
                                                                          "geomFeature",
                                                                          "geomMeasure")],
                                names_from = c(verbose_cellID,geomFeature),
                                values_from = geomMeasure)
          
head(wider_long_join_cellAndTime)


```


```{r}

#pivot wider so that measure and cell ID are merged into one column 
#This makes it easy to use the syntax of "imputeTS" package, to remove NA with moving average or other
# wider_long_join_cellAndTime <- pivot_wider(long_join_cellAndtime_frame[,c("c_IDcellNumber_frame",
#                                                                           "timePoint_frame",
#                                                                           # "Treatment",
#                                                                           # "Row",
#                                                                           # "Column",
#                                                                           # "Plate",
#                                                                           "geomFeature",
#                                                                           "geomMeasure")],
#                                 names_from = c(c_IDcellNumber_frame,geomFeature),
#                                 values_from = geomMeasure)
# 
# head(wider_long_join_cellAndTime)
```


```{r}

# 
# # long_join_cellAndtime_frame$timePoint_frame <- paste0("time_",long_join_cellAndtime_frame$timePoint_frame)
# 
# #Because there are things where cellID has no value eg. Treatment, it creates more rows, so remove treatment
# 
# # colnames(long_join_cellAndtime_frame)
# 
# # wider_long_join_cellAndTime <- pivot_wider(long_join_cellAndtime_frame[,c("c_IDcellNumber_frame",
# #                                                                           "timePoint_frame",
# #                                                                           # "Treatment",
# #                                                                           # "Row",
# #                                                                           # "Column",
# #                                                                           # "Plate",
# #                                                                           "geomFeature",
# #                                                                           "geomMeasure")],
# #                                 names_from = c(timePoint_frame,
# #                                 values_from = geomMeasure)
#           
#               
# # wider_long_join_cellAndTime
# 
# colnames(wider_long_join_cellAndTime)

```

#make wider to group by cell
```{r}


# wider_long_join_cellAndTime <- pivot_wider(join_cellAndtime_frame,
#                                 names_from = c(verbose_cellID,join_cellAndtime_frame),
#                                 values_from = geomMeasure)
#           
#               
# wider_long_join_cellAndTime
# 
# 
# 
# join_cellAndtime_frame

```


#Impute NA or each time series (with a maxgap of 2)

```{r}
#arrange data
#group by cell number

# join_cellAndtime_frame
# 

library(dplyr)
library(imputeTS)


str(wider_long_join_cellAndTime)
wasNA_wider_long_join_cellAndTime <- lapply(wider_long_join_cellAndTime, is.na)



wide_group_impute_groupCellTime <- wider_long_join_cellAndTime %>%
  # filter()
  # select((where(is.numeric)))%>%
    # group_by(c_IDcellNumber_frame, geomFeature)%>%
     purrr::map_dfc(~na_ma(.x,k=1, maxgap =1))

#As above, but Do not impute first time point

wide_group_impute_groupCellTime

# 
# wide_group_impute_groupCellTime
# 
# groupCellTime <- join_cellAndtime_frame %>%
#   arrange(c_IDcellNumber_frame,timePoint_frame)%>%
#   group_by(c_IDcellNumber_frame)
# 
# groupCellTime
# 
# 
# join_cellAndtime_frame
# 
# wide_groupCellTime <- wider_long_join_cellAndTime %>%
#   arrange(c_IDcellNumber_frame)%>%
#   group_by(c_IDcellNumber_frame)
# 
# head(groupCellTime)
# 
# #now impute
# 
# wide_group_impute_groupCellTime <- wide_groupCellTime %>%
#   # select((where(is.numeric)))%>%
#     group_by(c_IDcellNumber_frame, geomFeature)%>%
#      purrr::map_dfr(~na_ma(.x,k=1, maxgap =4))
# 
# wide_groupCellTime
# wide_group_impute_groupCellTime
# 
# 

# groupCellTime



```

#look for consecutive time series of 45
#Will only keep tracks with 45 consecutive time points
https://stackoverflow.com/questions/61841400/count-consecutive-non-na-items
```{r}
# Using rle in a (somewhat nested) lapply approach. We first list if an element of the data is.na. Then, using rle we
# decode values and lengths. Those lengths which are NA we set to 0 by multiplication and unlist the thing.
# x <- lapply(wide_group_impute_groupCellTime, is.na)
#   r <- rle(x$cell1__Volume_cell)
#   
#   s <- sapply(r$lengths, seq)
#   s
#   s[r$values]
#   lapply(s[r$values], `*`, 0)
#   s[r$values] <- lapply(s[r$values], `*`, 0)
#   unlist(s)
# 

library(ggplot2)

res <- as.data.frame(lapply(lapply(wide_group_impute_groupCellTime, is.na), function(x) {
  r <- rle(x)
  s <- sapply(r$lengths, seq)
  s[r$values] <- lapply(s[r$values], `*`, 0)
  unlist(s)
}))


maxRunPerCell <- sapply(res, max)
maxRunPerCell <- as.data.frame(maxRunPerCell)
ggplot(maxRunPerCell, aes(x = maxRunPerCell)) +
  geom_histogram()+
  geom_vline(xintercept = 45, color = "darkviolet")


```
#Subset based on run length
```{r}

dim(wide_group_impute_groupCellTime)
head(wide_group_impute_groupCellTime)
maxRunPerCell

Run_threshold <- 45

tracksWithRunLength_aboveThreshold <- which(maxRunPerCell >= Run_threshold)


runLengthFiltered_wide_group_impute_groupCellTime <- wide_group_impute_groupCellTime[,tracksWithRunLength_aboveThreshold] #filter

# maxRunPerCell2 <-  as.data.frame(maxRunPerCell2)
 # maxRunPerCell2 <- ggplot(maxRunPerCell2, aes(x = maxRunPerCell2)) +
   # geom_histogram()+
    # geom_vline(xintercept = 45, color = "darkviolet")

 # res2
```


#Run savitsky golay on all functions
# remove and re-add time column
#Create 
```{r}

# runLengthFiltered_wide_group_impute_groupCellTime$measureFilter <- paste0("noFilter") #Raw tracks with 45 or more time points and only gaps of 1 point
dim(runLengthFiltered_wide_group_impute_groupCellTime)

#run savitsky golay on all but time point column
savitsky_runLengthFiltered_wide_group_impute_groupCellTime <- lapply(runLengthFiltered_wide_group_impute_groupCellTime[,2:length(runLengthFiltered_wide_group_impute_groupCellTime)], function (x) sgolayfilt(x, p =3, n = 7, m = 0 , ts =1)) # Savitsky golay corrected tracks adjusting for noise

# savitsky_runLengthFiltered_wide_group_impute_groupCellTime


savitsky_runLengthFiltered_wide_group_impute_groupCellTime <- as.data.frame(savitsky_runLengthFiltered_wide_group_impute_groupCellTime) # make Savitsky filtered a dataframe
head(savitsky_runLengthFiltered_wide_group_impute_groupCellTime)

dim(savitsky_runLengthFiltered_wide_group_impute_groupCellTime) # check dim sg
length(runLengthFiltered_wide_group_impute_groupCellTime$timePoint_frame) # check length sg

timePoint_frame <- runLengthFiltered_wide_group_impute_groupCellTime$timePoint_frame # Make a list of time points to add to sgolay
savitsky_runLengthFiltered_wide_group_impute_groupCellTime <- cbind(savitsky_runLengthFiltered_wide_group_impute_groupCellTime, timePoint_frame) # join time back up to sg filtered data

# savitsky_runLengthFiltered_wide_group_impute_groupCellTime$time 
tail(colnames(savitsky_runLengthFiltered_wide_group_impute_groupCellTime)) # check that time has been added
savitsky_runLengthFiltered_wide_group_impute_groupCellTime <- savitsky_runLengthFiltered_wide_group_impute_groupCellTime %>%
  dplyr::select(timePoint_frame, everything()) # put time at front

colnames(savitsky_runLengthFiltered_wide_group_impute_groupCellTime)
```



# add type of filter to column names 
#so that savitsky and non savistky data can be treatead separately

```{r}
#add filter information to colnames
colnames(savitsky_runLengthFiltered_wide_group_impute_groupCellTime) <- paste0(colnames(savitsky_runLengthFiltered_wide_group_impute_groupCellTime),"_Filter_Savitsky")
colnames(runLengthFiltered_wide_group_impute_groupCellTime) <- paste0(colnames(runLengthFiltered_wide_group_impute_groupCellTime),"_Filter_noFilter")

#get subset of "WasNA that is in the run length filtered groups"
filtNames <- colnames(savitsky_runLengthFiltered_wide_group_impute_groupCellTime)
gsub("_Filter_Savitsky","", savitsky_runLengthFiltered_wide_group_impute_groupCellTime )

filtNames <- colnames(savitsky_runLengthFiltered_wide_group_impute_groupCellTime)

# filtNames

head(colnames(savitsky_runLengthFiltered_wide_group_impute_groupCellTime))#This can be used for ACF function



#join savitsy and non savitsky
#then make both longer

join_naImpute45_orMore_SavitskyAndRaw <-cbind(runLengthFiltered_wide_group_impute_groupCellTime, savitsky_runLengthFiltered_wide_group_impute_groupCellTime[-1]) # join all data and savitsky minus time frame
names(join_naImpute45_orMore_SavitskyAndRaw)[names(join_naImpute45_orMore_SavitskyAndRaw) == 'timePoint_frame_Filter_noFilter'] <- 'timePoint_frame_Filter' # rename the time frame data

tsList_naImpute_45times_savitsky <- join_naImpute45_orMore_SavitskyAndRaw

head(tsList_naImpute_45times_savitsky)
                                                                                                                                    
#if cell is in join is in column names of 
head(wasNA_wider_long_join_cellAndTime)      

head(

#make longer before joining
long_join_naImpute45_orMore_SavitskyAndRaw <- pivot_longer(join_naImpute45_orMore_SavitskyAndRaw,
                                       cols = c(2:length(join_naImpute45_orMore_SavitskyAndRaw)),
                                       names_to = "cellID_geomFeature",
                                       values_to = "geomMeasure")


#create cellID column by extracting cell number
#create geomFeatureColumn by extract geom feature
#create Filter column by extracting Savitsky
# long_join_naImpute45_orMore_SavitskyAndRaw


View(long_join_naImpute45_orMore_SavitskyAndRaw)

```

#split dataframe into list of time series with CellID, feature and transoformation information
```{r}
sorted_tsList_naImpute_45times_savitsky <- tsList_naImpute_45times_savitsky %>%
     arrange(timePoint_frame_Filter)

sorted_tsList_naImpute_45times_savitsky

sorted_tsList_naImpute_45times_savitsky <- sorted_tsList_naImpute_45times_savitsky[]
  
sorted_tsList_naImpute_45times_savitsky
# str(sorted_wide_cellID_geomFeature)

tsImpute_listOfCellsAndFeautres <- list()                   # Create empty list
print(paste("start time..",Sys.time()))
for(i in 1:ncol(sorted_tsList_naImpute_45times_savitsky)) {             # Using for-loop to add columns to list
 tsImpute_listOfCellsAndFeautres[[i]] <- pull(sorted_tsList_naImpute_45times_savitsky, i)
  # listOfCellsAndFeautres[[i]] <- sorted_wide_cellID_geomFeature[ , i]
}
# str(listOfCellsAndFeautres)

str(tsImpute_listOfCellsAndFeautres)

tsImpute_wholelistOfCellsAndFeautres <- tsImpute_listOfCellsAndFeautres

#remove first column (run number)
tsImpute_listOfCellsAndFeautres <- tsImpute_wholelistOfCellsAndFeautres[-1]
# str(listOfCellsAndFeautres)
#remove first column for names
tsImpute_names_of_cellsAndFeatures <- colnames(sorted_tsList_naImpute_45times_savitsky[,-1])

str(tsImpute_listOfCellsAndFeautres)
# str(listOfCellsAndFeautres)

print(paste("End time..",Sys.time()))

str(head(tsImpute_listOfCellsAndFeautres))

# str(listOfCellsAndFeautres)

names(tsImpute_listOfCellsAndFeautres) <- tsImpute_names_of_cellsAndFeatures    # Rename list elements

# head(listOfCellsAndFeautres)
# str(listOfCellsAndFeautres)
# dir.create("output")
```


```{r}

dir.create(file.path("output_csv"), showWarnings = FALSE)
# setwd(file.path(mainDir, subDir))
write.csv(tsImpute_listOfCellsAndFeautres,"output_csv/tsImpute_listOfCellsAndFeautres.csv")
```


#get out metadata and create new columsn from it
# grep and stringr for
# geomFeature
# measureFilter
# cellID
```{r}
library(stringr)
head(long_join_naImpute45_orMore_SavitskyAndRaw$cellID_geomFeature)
long_join_naImpute45_orMore_SavitskyAndRaw$cellID <- as.numeric(gsub("cell.*?([0-9]+).*", "\\1", long_join_naImpute45_orMore_SavitskyAndRaw$cellID_geomFeature))             
# long_join_naImpute45_orMore_SavitskyAndRaw$cellID <- as.numeric(gsub("cell.*?([0-9]+).*", "\\1", long_join_naImpute45_orMore_SavitskyAndRaw$cellID_geomFeature)) 
featureRes<- str_match(long_join_naImpute45_orMore_SavitskyAndRaw$cellID_geomFeature, "__\\s*(.*?)\\s*_Filter");
# featureRes[,2]
long_join_naImpute45_orMore_SavitskyAndRaw$geomFeature <- featureRes[,2]
long_join_naImpute45_orMore_SavitskyAndRaw$measureFilter <- gsub(".*_Filter_","\\1",long_join_naImpute45_orMore_SavitskyAndRaw$cellID_geomFeature); #https://statisticsglobe.com/extract-substring-before-or-after-pattern-in-r


long_join_naImpute45_orMore_SavitskyAndRaw$merge_cellID_Filter <- paste(long_join_naImpute45_orMore_SavitskyAndRaw$cellID,long_join_naImpute45_orMore_SavitskyAndRaw$measureFilter,sep="_")

# print(hello)



# View(head(long_join_naImpute45_orMore_SavitskyAndRaw))

# print(res)

# long_naImpute45_orMore

# naImpute_45orMore_SavitskyTracks <- 

# https://stackoverflow.com/questions/57204659/how-to-extract-everything-after-a-specific-string
  # library(stringr)
# str_extract(test, '\\b\\w+$')
# str_split(test, '__', simplify = TRUE)[,2]
# sapply(strsplit(test, '-'), `[`, 2)

# https://stackoverflow.com/questions/39086400/extracting-a-string-between-other-two-strings-in-r

# library(stringr)


# ?gsub()  

# sapply(strsplit(long_naImpute45_orMore$cellID_geomFeature,"__"),"[",2)
?'['

```


#Widen the chart to put features on y axis
```{r}



```

#Have a look at some savitsky vs normal
```{r}


# long_join_naImpute45_orMore_SavitskyAndRaw

head(unique(long_join_naImpute45_orMore_SavitskyAndRaw$measureFilter))

colnames(long_join_naImpute45_orMore_SavitskyAndRaw)


long_join_naImpute45_orMore_SavitskyAndRaw$cellID <- as.factor(long_join_naImpute45_orMore_SavitskyAndRaw$cellID)

unique(long_join_naImpute45_orMore_SavitskyAndRaw$geomFeature)
ggplot(long_join_naImpute45_orMore_SavitskyAndRaw[long_join_naImpute45_orMore_SavitskyAndRaw$cellID == 116 & long_join_naImpute45_orMore_SavitskyAndRaw$geomFeature == "Volume_nucleus", ], aes(x=timePoint_frame_Filter, y = geomMeasure, color = measureFilter, group = merge_cellID_Filter ))+
  geom_line()+
  facet_wrap(~geomFeature ~ measureFilter , scale = "free")


unique(long_join_naImpute45_orMore_SavitskyAndRaw$geomFeature)
ggplot(long_join_naImpute45_orMore_SavitskyAndRaw[long_join_naImpute45_orMore_SavitskyAndRaw$cellID == 116 & long_join_naImpute45_orMore_SavitskyAndRaw$geomFeature == "Volume_nucleus", ], aes(x=timePoint_frame_Filter, y = geomMeasure, color = measureFilter, group = merge_cellID_Filter ))+
  geom_line()+
    scale_color_manual(values = c("navy","violetred"))+
  facet_wrap(~geomFeature ~ measureFilter , scale = "free")+
  theme_classic()

unique(long_join_naImpute45_orMore_SavitskyAndRaw$geomFeature)
ggplot(long_join_naImpute45_orMore_SavitskyAndRaw[long_join_naImpute45_orMore_SavitskyAndRaw$cellID == 116 & long_join_naImpute45_orMore_SavitskyAndRaw$geomFeature == "Volume_nucleus", ], aes(x=timePoint_frame_Filter, y = geomMeasure, color = measureFilter, group = merge_cellID_Filter ))+
  geom_line()+
    scale_color_manual(values = c("navy","violetred"))+
  # facet_wrap(~geomFeature ~ measureFilter , scale = "free")+
  theme_classic()

ggplot(long_join_naImpute45_orMore_SavitskyAndRaw[long_join_naImpute45_orMore_SavitskyAndRaw$geomFeature == "Volume_nucleus", ], aes(x=timePoint_frame_Filter, y = geomMeasure, color = measureFilter, group = merge_cellID_Filter ))+
  geom_line(alpha =0.5)+
  facet_wrap(~geomFeature  , scale = "free")+
     scale_color_manual(values = c("navy","violetred"))+
  # facet_wrap(~geomFeature ~ measureFilter , scale = "free")+
  theme_classic()





```



#Write out data
```{r}

head(long_join_naImpute45_orMore_SavitskyAndRaw)

head(long_join_naImpute45_orMore_SavitskyAndRaw)
write.csv(long_join_naImpute45_orMore_SavitskyAndRaw, file = "long_naImpute_45_savitsky.csv")

```


#scale tracks (z score them)?
```{r}

```



```{r}

# S3 method
# sgolayfilt(x, p = 3, n = p + 3 - p%%2, m = 0, ts = 1)

# wide_group_impute_groupCellTime$cell1__Volume_cell

savitzkyGolay(wide_group_impute_groupCellTime$cell1__Volume_cell,m =1 ,p =3 ,w = 5) # This filter changes the length of the time series

sgolayfilt(wide_group_impute_groupCellTime$cell1__Volume_cell)
sgolayfilt(wide_group_impute_groupCellTime$cell1__Volume_cell, p =3, n = 5, m = 0 , ts =1)

# # S3 method for sgolayFilter
# # filter(filt, x, â€¦)
# 
# # savitzkyGolay(X, m, p, w, delta.wav)
# 
# # NOT RUN {
# # Compare a 5 sample averager, an order-5 butterworth lowpass
# # filter (cutoff 1/3) and sgolayfilt(x, 3, 5), the best cubic
# # estimated from 5 points.
# bf <- butter(5,1/3)
# x <- c(rep(0,15), rep(10, 10), rep(0, 15))
# sg <- sgolayfilt(x)
# plot(sg, type="l")
# lines(filtfilt(rep(1, 5)/5,1,x), col = "red") # averaging filter
# lines(filtfilt(bf,x), col = "blue")           # butterworth
# points(x, pch = "x")                          # original data
# # }


```
#Two functions 
#S golay and savistzkyGolay

```{r}
#raw beginning
# wider_long_join_cellAndTime
# 
# #imputed
# wide_group_impute_groupCellTime


# test_Savitsky <- wide_group_impute_groupCellTime$cell1__Volume_cell %>% savitzkyGolay(.,m =1 ,p =3 ,w = 11)
test_Savitsky <- sgolayfilt(wide_group_impute_groupCellTime$cell1__Volume_cell, p =3, n = 11, m = 0 , ts =1)

?sgolayfilt()

sav_compare1 <- data.frame(time = wide_group_impute_groupCellTime$timePoint_frame,
                           volume = wide_group_impute_groupCellTime$cell1__Volume_cell,
                           transform = "raw")
sav_compare2 <- data.frame(time = wide_group_impute_groupCellTime$timePoint_frame, 
                           volume = test_Savitsky,
                           transform = "savitsky")
sav_compare <- rbind(sav_compare1)
sav_compare_both <- rbind(sav_compare,sav_compare2)



library(ggplot2)
ggplot(sav_compare_both, aes(x=time, y=volume, color = transform, group =transform))+
         geom_line()+
  scale_color_manual(values = c("navy","violetred"))+
  theme_classic()
  

length(wide_group_impute_groupCellTime$cell1__Volume_cell)
test_Savitsky


ggplot(sav_compare_both, aes(x=time, y=volume, color = transform, group =transform))+
         geom_line()+
  scale_color_manual(values = c("navy","violetred"))+
  theme_classic()
#https://www.rdocumentation.org/packages/signal/versions/0.7-7/topics/sgolayfilt

# sgolayfilt(x, p = 3, n = p + 3 - p%%2, m = 0, ts = 1)



# savitsky_wide_group_impute_groupCellTime <- sapply(wide_group_impute_groupCellTime, savitzkyGolay)

#sovitsky golay

# # NOT RUN {
# data(NIRsoil)
# opar <- par(no.readonly = TRUE)
# par(mfrow = c(2, 1), mar = c(4, 4, 2, 2))
# 
# # plot of the 10 first spectra
# matplot(as.numeric(colnames(NIRsoil$spc)),
#   t(NIRsoil$spc[1:10, ]),
#   type = "l",
#   xlab = "",
#   ylab = "Absorbance"
# )
# 
# mtext("Raw spectra")
# NIRsoil$spc_sg <- savitzkyGolay(
#   X = NIRsoil$spc,
#   m = 1,
#   p = 3,
#   w = 11,
#   delta.wav = 2
# )
# 
# matplot(as.numeric(colnames(NIRsoil$spc_sg)),
#   t(NIRsoil$spc_sg[1:10, ]),
#   type = "l",
#   xlab = "Wavelength /nm",
#   ylab = "1st derivative"
# )
# 
# mtext("1st derivative spectra")
# par(opar)
# 
# # }
```


#Select all time series with more than 45 good time points (and only 1 NA imputed)

#Run length of non na value
https://stackoverflow.com/questions/6808621/find-the-index-position-of-the-first-non-na-value-in-an-r-vector

```{r}

# NonNAindex <- which(!is.na(z))
# firstNonNA <- min(NonNAindex)
# 
# # set the next 3 observations to NA
# is.na(z) <- seq(firstNonNA, length.out=3)
# 
# t45good_1maxGap <- wide_group_impute_groupCellTime %>%
#   select()

```

#Savitsky golay
https://www.rdocumentation.org/packages/prospectr/versions/0.2.2/topics/savitzkyGolay
```{r}



```


#Savitsky golay tests
```{r}
# #impute missing values (as average of time point either side)
# # https://cran.r-project.org/web/packages/imputeTS/vignettes/imputeTS-Time-Series-Missing-Value-Imputation-in-R.pdf
#  # if(!(require(imputeTs))){install.packages("imputeTS")}
# library(imputeTS)
# 
# groupCellTime
# 
# #https://rstudio-education.github.io/tidyverse-cookbook/transform-lists-and-vectors.html
# 
# impute_groupCellTime <- groupCellTime %>%
#   select((where(is.numeric)))%>%
#      na_ma(k=1)
# 
# impute_groupCellTime
# 
# library(purrr)
# 
# groupCellTime
# 
# #https://stackoverflow.com/questions/49724457/how-to-pass-second-parameter-to-function-while-using-the-map-function-of-purrr-p
# #https://dplyr.tidyverse.org/reference/group_map.html
# 
# groupCellTime
# 
# 
# groupCellTime
# 
# group_impute_groupCellTime <- head(groupCellTime,100) %>% 
#   # as_tibble()%>%
#   select((where(is.numeric)))%>%
#      group_by(c_IDcellNumber_frame)%>%
#    # purrr::map_dfc(~na_ma(.x,k=1, maxgap =2))%>%
#    # map_dfc(~na_ma(.x,k=1,maxgap =1))
#    group_map(~na_ma(.x,k=1, maxgap =1))
#   # data.frame()
# 
#   
#   #Split dataframe into groups so that each group is a vector
#   #Dp this by making long with Cell_ID_
#   
# 
# group_impute_groupCellTime
# # ?map()
# 
# # ?group_map()
# 
# group_impute_groupCellTime
# 
# impute_groupCellTime
# 
# groupCellTime %>% na_ma(maxgap=c(4))
# 
# # groupCellTime$Volume_cell %>% na_ma(maxgap = 
# 
# # ?map_dfr()
# 
# # ?na_ma()
# 
# # groupCellTime
#                      
# # impute_groupCellTime



```
